<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <div id="point" onclick="setTimeout(msg)" style="width: 100px; height: 100px; background-color:aqua"></div>
  <script type="text/javascript">
    // XSS(Cross-Site Scripting):跨站脚本攻击。顾名思义就是通过向网站写入js脚本来实现攻击。
    // CSRF(Cross-site Request Forgery):跨站点伪造请求。该攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，
    // 	从而在未授权的情况下执行权限保护之下的操作，具有很大的危害性。
    
    // XSS攻击分为三种：
    //   1.存储型xss：攻击者将恶意代码提交到目标网站的数据库中，服务起将带有恶意代码的页面返回给浏览器解析，执行恶意代码，从而盗取用户信息或者冒充用户的行为。例如：论坛发帖、商品评价、用户私信等。
    //   2.反射型xss：攻击者构造出特殊的url，其中包含恶意代码。用户打开url，服务器将恶意代码从url中取出，拼接在html返回浏览器解析，执行恶意代码，从而盗取用户信息或者冒充用户的行为。例如：网站搜索、跳转等
    //   3.dom型xss:攻击者构造出特殊的url，其中包含恶意代码。用户打开url，前端javascript将恶意代码从url中取出，拼接在html返回浏览器解析，执行恶意代码，从而盗取用户信息或者冒充用户的行为。
    //   dom型xss跟前两种xss的区别是：去除恶意代码由浏览器完成，属于前端javascript自身的安全漏洞，而其他两种都是属于服务器的安全漏洞。
    // XSS预防：
        // 存储型和反射型xss攻击预防：两者都是服务器取出恶意代码后，插入到html里面，被浏览器执行
        //   1.改成纯前端渲染，把代码和数据分隔开。
        //   2.对html做充分转义。
        // dom型xss攻击：就是网站前端javascript代码不够严谨，把不可信的数据当做代码执行了。
        //   1.在使用.innerHtml、.outerHTML、document.write时要非常小心，不可把不可信的数据作为HTML插到网页。
        //   2.dom内联时间监听器，如：location、onclick、onerror、onload、onmousemove等，<a>标签的href属性，javascript中的eval、setTimeout、setInterval等都可把字符串作为代码运行。
        //     如果不可信的数据拼接到字符串传递给这些api，很容易产生安全隐患，务必避免。
        // 输入内容长度控制：对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止xss发生，但可以增加xss攻击的难度
        // 其他安全措施：
        //   1.http-only Cookie:禁止javascript读取某些敏感cookie，攻击者完成xss注入后也就无法窃取cookie
        //   2.验证码：防止脚本冒充用户提交危险操作。
        // 避免内联事件：尽量不要使用onload="onload('{{data}}')",onClick="go('{{action}}')"这种拼接内联时间的写法。在javascript中使用addEventListener绑定事件更安全。
        // 避免拼接html
        // 检查referer：即检查请求头的来源网站，从而保证此次请求来源于信任的网站。



    // 纯前端渲染：
    //   1.浏览器先加载一个静态html，此html不包含任何跟业务相关数据。
    //   2.然后浏览器执行html中的javascript。
    //   3.javascript通过ajax加载业务数据，调用dom api更新到页面上。
    // 在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本(.innerText)，还是属性(.setAttribute)，还是样式(.style)等等。浏览器不会被轻易的欺骗，执行预期外的代码了。
    // 单纯前端渲染还需要避免dom型xss攻击（例如onload事件和href中的javascript：xxx等）。
    // 但对于性能要求高，或有SEO需求的页面，我们仍然要面对拼接html的问题。

    // html转义：html的转义非常复杂，要根据不同的上下文使用相应的转义规则。如：
    //     1.html标签内文字内容：<div> < %=   Encode.forHtml ( UNTRUSTED ) %> </div>
    //     2.html标签属性值:< input   value = "<%= Encode.forHtml(UNTRUSTED) %>"  />
    //     3.css属性值:< div   style = "width:<= Encode.forCssString(UNTRUSTED) %>" > 
    //     4.css url:< div   style = "background:<= Encode.forCssUrl(UNTRUSTED) %>" > 
    //     5.javascript内联代码块:
    //       < script >  
    //       var  msg =  "<%= Encode.forJavaScript(UNTRUSTED) %>" ;
    //       alert(msg);
    //       </ script > 
    //     6.javascript内联代码块内联JSON:
    //       < script >  
    //       var  __INITIAL_STATE__ =  JSON .parse( '<%= Encoder.forJavaScript(data.to_json) %>' );
    //       </ script > 
    //     7.URL 参数: < a   href = "/search?value=<%= Encode.forUriComponent(UNTRUSTED) %>&order=1#top" > 
    //     8.URL 路径: < a   href = "/page/<%= Encode.forUriComponent(UNTRUSTED) %>" > 

    window.msg = 'alert(1)';
    window.getArgs = function() {
      if (!location.search) return {};
      var search = location.search.slice(1).split('&');
      var result = {};
      for (var i = 0; i < search.length; i++) {
          var item = search[i].split('=');
          var key = item[0];
          var value = item[1];
          result[key] = value;
      }
      return result;
    }

  </script>

<a href="javascript:setTimeout('alert(1)')">点击我呀</a>
</body>

</html>