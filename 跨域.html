<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>跨域</title>
</head>

<body>
  <script>
    // 同源策略：所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。
		// 同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。
		// 同源策略限制内容有：
		// 	1.Cookie、localstorage、IndexedDB等存储性内容。
		// 	2.DOM节点
		// 	3.ajax请求发送后，结果被浏览器拦截了。
		// 但是有三个标签是允许跨域加载资源的：img、link、script。
		// 注：跨域并不是发布出去请求，请求能发出去，服务器端能接收到请求并能正确返回结果，只是结果被浏览器拦截了。
    // 	同时也说明了跨域并不能完全阻止CSRF，因为请求毕竟发出去了。
    
    // 跨域方式：jsonp、cors、postMessage、Node中间件、window.name+iframe、window.hash+iframe、window.domain+iframe
    // 1.jsonp: 利用script标签没有跨域限制的漏洞，网页可以得到从其他来源动态生成的json数据。jsonp请求一定需要对方的服务器做支持才可以。
		// 		JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）。
		// 		JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。
		// 		JSONP的实现流程：
		// 			1).声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。
		// 			2).创建一个<script>标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。
		// 			3).服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是show('我不爱你')。
		// 			4).最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作
		// 		function jsonp({ url, params, callback }) {
		// 			return new Promise((resolve, reject) => {
		// 				let script = document.createElement('script');
		// 				window[callback] = function(data) {
		// 					resolve(data);
		// 					document.body.removeChild(script);
		// 				}
		// 				params = { ...parens, callback};
		// 				let arrs = [];
		// 				for (let key in params) {
		// 					arrs.push(`${key}=${params[key]}`);
		// 				}
		// 				script.src = `${url}?${arrs.join('&')}`;
		// 				document.body.appendChild(script);
		// 			});
		// 		}
		// 		jsonp({
		// 			url: 'http://localhost:3000/say',
		// 			params: { wd: 'Iloveyou'},
		// 			callback: 'show'
		// 		}).then(data => {
		// 			console.log(data);
		// 		});
		// 		上面这段代码相当于向http://localhost:3000/say?wd=Iloveyou&callback=show。
		// 		jquery的jsonp：
		// 			$.ajax({
		// 				url:'',
		// 				dataType:'jsonp',
		// 				type: 'get',
		// 				jsonCallback: 'show',
		// 				jsonp: 'callback',
		// 				success: function(data) {
		// 					console.log(data);
		// 				},
    // 			});
    // 2.cors(cross-origin resource sharing):跨域资源共享是一种机制，它使用额外的HTTP头来告诉浏览器，
		// 		让运行一个origin上的web应用被准许访问来自不同源服务器上的指定的资源。
		// 		浏览器会自动进行cors通信，实现cors通信的关键是后端。只要后端实现了cors，就实现了跨域。
		// 		简单请求：
		// 			满足条件1：使用GET、HEAD或者POST方法，
		// 			满足条件2：Content_type的值仅限于：text/plain、multipart/form-data、application/x-www-form-urlencoded。
		// 			满足条件3：请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象可以使用XMLHttpRequest.upload属性访问。
		// 		复杂请求：不满足简单请求的即为复杂请求。
		// 			复杂请求的cors请求，会在正式通信之前，增加一次http查询请求，称为‘预检’请求，该请求是option方法，通过该请求来知道服务端是否允许跨域请求。
		// 			// index.html (localhost:3000)
		// 			let hrx = new XMLHttpRequest();
		// 			document.cookie = 'name=along'; // cookie不能跨域
		// 			xhr.withCredentials = true; // 前端设置是否带cookie
		// 			xhr.open('PUT', 'http://localhost:4000/getData', true);
		// 			xhr.setRequestHeader('name', 'along');
		// 			xhr.onreadystatechange = function() {
		// 				if (xhr.readyState == 4) {
		// 					if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
		// 						console.log(xhr.response);
		// 						console.log(xhr.getResponseHeader('name'));
		// 					}
		// 				}
		// 			}
		// 			// server.js (localhost:4000)
		// 			let express = require('express');
		// 			let app = express();
		// 			let whiteList = ['http://localhost:3000']; // 设置白名单 
		// 			app.use(function(req,res,next) {
		// 				let origin = req.headers.origin;
		// 				if (whiteList.includes(origin)) {
		// 					res.setHeader('Access-Control-Allow-Origin', origin); // 设置哪个源可以访问我
		// 					res.setHeader('Access-Control-Allow-Header', 'name'); // 允许携带哪个头来访问我
		// 					res.setHeader('Access-Control-Allow-Methods', 'PUT'); // 允许哪个方法访问我
		// 					res.setHeader('Access-Control-Allow-Credentials', true); // 允许携带cookie
		// 					res.setHeader('Access-Control-Max-Age',  86400); // 有效时间为 86400 秒，也就是24小时
		// 					res.setHeader('Access-Control-Expose-Headers', 'name'); // 允许返回的头
		// 					if (req.method == 'OPTION') {
		// 						res.end(); // OPTION请求不做任何处理
		// 					}
		// 				}
		// 			});

		// 			app.put('/getData', function(req, res) {
		// 				console.log(req.header);
		// 				res.setHeader('name', 'jw'); // 返回一个响应头， 后台设置
		// 				res.end('我不爱你');
		// 			});

		// 			app.use(express.static(__dirname));
		// 			app.listen(4000);

		// 			上述代码时http://localhost:3000/index.html向http://localhost:4000/ 跨域请求。正如上面所说的，后端是实现CORS通信的关键。
    // 			IE 8 和 9 需要通过 XDomainRequest 来实现。
    // 3.postMessage：是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一。
		// 		它可用于解决以下方面的问题：
		// 			1.页面和其打开的新窗口的数据传递。
		// 			2.多窗口之间消息传递。
		// 			3.页面与嵌套的iframe消息传递。
		// 			postMessage(message, targetOrigin, [transfer])方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。
		// 				message：将要发送到其他 window的数据。
		// 				targetOrigin：通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。
		// 				transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。
					
		// 			// a.html (localhost:3000)
		// 			<iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"></iframe>
		// 			<script>
		// 				function load() {
		// 					let frame = document.getElementById('frame');
		// 					frame.contentWindow.postMessage('我爱你', 'http://localhost:4000'); //发送数据
		// 					window.onmessage = function(e) { //接受返回数据
		// 						console.log(e.data);
		// 					}
		// 				}
		// 			// b.html (localhost:4000)
		// 			window.onmessage = function(e) {
		// 				console.log(e.data);
		// 				e.source.postMessage('我不爱你'， e.origin);
		// 			}
    // 			以上代码实现 http://localhost:3000/a.html页面向http://localhost:4000/b.html传递“我爱你”,然后后者传回”我不爱你”。
    // 4.Node中间件代理（两次跨域）：同源策略是浏览器需要遵守的标准，而如果是服务器向服务器请求就无需遵循同源策略了。
		// 		// index.html(http://127.0.0.1:5500)
 		// 		<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js">
		// 		<script>
		// 			$.ajax({
		// 				url: 'http://localhost:3000',
		// 				type: 'post',
		// 				data: { name: 'xiamen', password: '123456' },
		// 				contentType: 'application/json;charset=utf-8',
		// 				success: function(result) {
		// 				console.log(result) // {"title":"fontend","password":"123456"}
		// 				},
		// 				error: function(msg) {
		// 				console.log(msg)
		// 				}
		// 			})
		// 		// server1.js 代理服务器(http://localhost:3000)
		// 		const http = require('http');
		// 		// 第一步：接受客户端请求
		// 		const server = http.createServer((req, res) => {
		// 			// 与浏览器直接对接 跨域需要设置CORS 的首部字段
		// 			response.writeHead(200, {
		// 				'Access-Control-Allow-Origin': '*',
		// 				'Access-Control-Allow-Methods': '*',
		// 				'Access-Control-Allow-Headers': 'Content-Type',
		// 			});
		// 			// 第二步：将请求转发给服务器
		// 			const proxyRequest = http.request({
		// 				host: '127.0.0.1',
		// 				port: '4000',
		// 				url: '/',
		// 				method: req.method,
		// 				headers:req.headers,
		// 			}, serverResponse => {
		// 				// 第三步：收到服务器的响应
		// 				let body = '';
		// 				serverResponse.on('data', chunck => {
		// 					body += chunck;
		// 				});
		// 				serverResponse.on('end', () => {
		// 					// 第四步：将响应结果转发给浏览器
		// 					console.log('The data is'+ body);
		// 					res.end(body);
		// 				})
		// 			});
		// 		});
		// 		server.listen(3000, () => {
		// 			console.log('The proxyServer is running at http://localhost:3000')
		// 		})
		// 		// server2.js(http://localhost:4000)
		// 		const http = require('http');
		// 		const data = { title: 'fontend', password: '123456' };
		// 		const server = http.createServer((req, res) => {
		// 			if (req.url === '/') {
		// 				response.end(JSON.stringify(data));
		// 			}
		// 		});
		// 		server.listen(4000, () => {
		// 			console.log('The server is running at http://localhost:4000')
		// 		})
		// 		以上代码实现本地文件(localhost:5500)index.html文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据。
		// 5.window.name + iframe: window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。
		// 	 // a.html(http://localhost:3000/b.html)
		// 	 <iframe src="http://localhost:4000/c.html" frameborder="0" onload="load()" id="iframe"></iframe>
		// 	 <script>
		// 		let first = true;
		// 		function load() {
		// 			if (first) {
		// 				let iframe = document.getElementById('iframe');
		// 				iframe.src = "http://localhost:3000/b.html";
		// 				first = false;
		// 			} else {
		// 				console.log(iframe.contentWindow.name);
		// 			}
		// 		}
		// 	 // c.html(http://localhost:4000/c.html)
		// 		window.name = '我不爱你';
		// 	以上代码a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000
		// 	通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。
		// 	这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。
		// 6.window.hash + iframe: a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
		// 	// a.html
		// 	<iframe src="http://localhost:4000/c.html#iloveyou"></iframe>
		// 		window.onhashchange = function () { //检测hash的变化
		// 		console.log(location.hash);
		// 		}
		// 	// b.html
		// 		window.parent.parent.location.hash = location.hash;  //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面
		// 	// c.html
		// 	console.log(location.hash);
		// 	let iframe = document.createElement('iframe');
		// 	iframe.src = 'http://localhost:3000/b.html#idontloveyou';
		// 	document.body.appendChild(iframe);
		// 	一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。
		// 7.window.domain + iframe:给页面添加 document.domain ='test.com' 表示二级域名都相同就可以实现跨域。
		// 	该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。
		// 	// a.html
		// 	<iframe src="http://b.zf1.cn:3000/b.html" frameborder="0" onload="load()" id="frame"></iframe>
		// 		document.domain = 'zf1.cn'
		// 		function load() {
		// 		console.log(frame.contentWindow.a);
		// 		}
		// 	// b.html
		// 		document.domain = 'zf1.cn'
		// 		var a = 100;
		// 	以上代码实现页面a.zf1.cn:3000/a.html获取页面b.zf1.cn:3000/b.html中a的值。
		// 8.nginx反向代理：实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。

  </script>
</body>

</html>