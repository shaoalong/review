<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>性能优化</title>
</head>

<body>
  <script>
    // 页面优化/服务器优化/cookie/js/css/图片/缓存

    // 网页内容：
    //     减少http请求：
    //         1.捆绑文件（js/css combine 合并文件）
    //         2.css sprites（雪碧图）
    //         3.inline images（base64）
    //     减少DNS查询次数：如果我们的网页内容来自不同的domain（比如嵌入了开放广告，引用了外部图片或脚本），那么客户端首次解析呃写domain
    //         也消耗一定的时间。DNS查询结果缓存在本地系统和浏览器中一段时间，所以DNS查询一般是对首次访问响应速度有所影响。
    //     缓存ajax：
    //         1.添加expires或者cache-control报文头使回复可以被缓存。
    //         2.配置Etag。
    //         3.避免跳转。
    //         4.压缩回复内容。
    //     异步加载（异步加载与页面文档并行，但执行为串行）
    //         defer： 与页面文档并行加载；在页面解析渲染之后，等到所有defer脚本加载完毕完按顺序执行。（可以操作dom）
    //         async：与页面文档并行加载；但是执行脚本加载完即执行，执行没有顺序。（不可操作dom）
    //     提前加载（预加载）
    //     减少DOM元素数量
    //     减少iframe数量：
    //         iframe优点：
    //             1.可以用来加载速度比较慢的的内容，比如广告。
    //             2.脚本可以并行下载。
    //         iframe缺点：
    //             1.即使iframe内容为空也消耗加载时间。
    //             2.会阻止页面加载。
    // 服务器：
    //     使用CDN（内容分发网络）提高下载速度
    //         1.浏览器输入要访问的域名
    //         2.浏览器向dns服务器请求对域名进行解析。由于cdn对域名解析进行了调整，dns服务器会最终将域名的解析权交给cname指向的cdn专用dns服务器。
    //         3.cdn的dns服务器将cdn的负载均衡设备IP地址返回给用户。
    //         4.用户向cdn负载均衡设备发起内容url访问请求。
    //         5.cdn负载设备会为用户选择一台合适的缓存服务器提供服务。
    //         6.用户向缓存服务器发出请求。
    //         7.缓存服务器应用户请求，将用户所需要内容传送给用户。如果这台缓存服务器上没有用户想要的内容，而负载均衡设备依然将它分配给用户，那么这台服务器
    //             就要向它上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。
    //     添加Expires或cache-control报文头：
    //         1.对于静态内容添加expires，将静态内容设为永不过期，或者很长时间以后。
    //         2.对于动态内容应用适合的cache-control，让浏览器根据条件来发送请求。
    //     Gzip压缩传输文件：Gzip通常可以减少70%网页内容的大小，包括脚本、样式表、图片等文件。
    //     配置Etag。
    //     使用get ajax请求：
    //         浏览器在实现XMLHttpRequest Post的时候分成两步，先发header，然后发送数据。而get却可以用一个TCP报文完成求情。
    //         从语义上来说，get是请求获取数据，post是发送数据。所以我们使用ajax请求数据的时候尽量通过get来完成。
    //     避免空的图片src：
    //         空的图片src仍然会使浏览器发送请求到服务器，这样完全是浪费时间，而且浪费服务器的资源。尤其是你的网站每天呗很多人访问，
    //         这种空请求造成的伤害不容忽视。
    //         解决办法：
    //             1.尽量避免使用空的img。
    //             2.服务端，如果发现这种无意义的请求时不要返回任何东西给前端。
    // cookie：
    //     减少cookie大小：
    //         1.去除没有必要的cookie。
    //         2.将cookie的大小见到最小。
    //         3.注意cookie设置的domain级别，没有必要情况下不要影响到sub-domain
    //         4.设置合适的过期时间，比较长的过期时间可以提升响应速度。
    //     domain hash: 
    //         浏览器对并发请求的数目限制是针对域名(domain)的，即针对同一域名（包括二级域名）在同一时间支持的并发请求数量。如果请求数目超出限制，则会阻塞。
    //         这也就衍生了domain hash技术来使用多个域名加大并发量（因为浏览器是基于domain的并发控制，而不是page），不过过多的散布会导致DNS解析上付出额外的代价，所以一般也是控制在2-4之间
    //     cookie-free:
    //         由于写在主域名下的cookie，如 xxx.com下的 cookie 比较大的情况下，若图片之类的 pic.xxx.com  图片去服务器取数据的时候，都需要发送本地的头，就会带上cookie，这样就会造成send数据过多，导致速度变慢像 js、style 等都会有这些问题。
    //         通常使用一个其他域名，这样这个域名下就没有cookie 了。
    //         因此，网站中对一些静态资源使用不同的一级域名（不可为二级域名，否则无济于事）可以提升浏览器对并行请求数目并且不再带有其他域名的cookie，加速界面资源的获取速度。
    //         常见的划分domain方式是将静态文件放在zhimg.com,动态文件放在zhihu.com。

    // CSS：
    //     将样式表置顶：
    //         样式表放在网页head中会让网页显得加载速度更快，因为这样做可以使浏览器逐步加载已经下载的网页内容。
    //         如果将样式表放在底部，浏览器会拒绝渲染已经下载的网页，因为大多数浏览器在实现时都努力避免重绘，样式表
    //         的内容是绘制网页的关键信息，没有下载下来之前之后对不起观众了。
    //     避免css表达式：
    //         css表达式可以动态的设置css属性，在IE5-IE8中支持，其他浏览器中表达式会被忽略。
    //         例：background-color：expression((new Date()).getHours()%2 ?  "#b8d4ff" : "#f08a00")
    //         css表达式的问题在于它呗重新计算的次数远比我们想象的多，不仅页面绘制或大小改变时计算，即使我们滚动屏幕或者移动鼠标
    //         的时候也在计算，因此我们尽量避免使用它来防止使用不当而造成的性能损耗。
    //     用link代替@import：
    //         避免使用@import的原因很简单，因为它相当于将css放在网页底部。

    // JS：
    //     将脚本置低：
    //         1.可以让页面渲染所需要的内容尽快加载现实的给用户。
    //         2.defer可以指定脚本在文档加载后执行。
    //         3.async可以让脚本异步执行。
    //     使用外部js和css文件： 使用外部js和css文件可以使这些文件被浏览器缓存，从而在不同请求内容之间重用，同时也减少了网页内容大小。
    //     精简js和css（去注释并压缩）
    //     减少DOM访问：通过js访问DOM元素没有我们想象中快。
    //         1.缓存已经访问过的元素
    //         2.离线更新节点然后再加回到DOM Tree
    // 图片：
    //     网站图标文件favicon.ico,不管你服务器有还是没有，浏览器都回去尝试请求这个图标。所以我们要确保有这个图标。
    //         1.存在
    //         2.文件尽量小，最好小于1k
    //         3.设置一个长的过期时间
    // 移动客户端：
    //     保持单个文件内容小于25k。这限制是因为iphone只能缓存小于25k，注意这是解压后的大小。

    favicon
  </script>
</body>

</html>