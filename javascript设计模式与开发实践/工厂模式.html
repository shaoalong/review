<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>工厂模式</title>
</head>

<body>
    <h2>
        工厂模式是用来创建对象的一种最常用的设计模式。我们不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和抽象工厂。
    </h2>

    <script>
        // 简单工厂模式又叫静态工厂模式，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。
        // 优点：你只需要一个正确的参数，就可以获取到你所需要的对象，而无需知道其创建的具体细节。
        // 缺点：但是在函数内包含了所有对象的创建逻辑（构造函数）和判断逻辑的代码，每增加新的构造函数还需要修改判断逻辑代码。当我们的对象不是上面的3个而是30个或更多时，这个函数会成为一个庞大的超级函数，便得难以维护。
        // 所以，简单工厂只能作用于创建的对象数量较少，对象的创建逻辑不复杂时使用。
        // let UserFactory = function(role) {
        //     function User(opt) {
        //         this.name = opt.name;
        //         this.viewPage = opt.viewPage;
        //     }
        //     switch (role) {
        //         case 'superAdmin': return new User({ name: '超级管理员', viewPage: ['首页', '通讯录', '发现页', '应用数据', '权限管理'] });
        //         case 'admin': return new User({ name: '管理员', viewPage: ['首页', '通讯录', '发现页', '应用数据'] });
        //         case 'user': return new User({ name: '普通用户', viewPage: ['首页', '通讯录', '发现页'] });
        //         default: new Error('参数错误, 可选参数:superAdmin、admin、user');
        //     }
        // }

        // class User {
        //     constructor(opt) {
        //         this.name = opt.name;
        //         this.viewPage = opt.viewPage;
        //     }

        //     static getTnstance(role) {
        //         switch (role) {
        //             case 'superAdmin':
        //                 return new User({
        //                     name: '超级管理员',
        //                     viewPage: ['首页', '通讯录', '发现页', '应用数据', '权限管理']
        //                 });
        //                 break;
        //             case 'admin':
        //                 return new User({
        //                     name: '管理员',
        //                     viewPage: ['首页', '通讯录', '发现页', '应用数据']
        //                 });
        //                 break;
        //             case 'user':
        //                 return new User({
        //                     name: '普通用户',
        //                     viewPage: ['首页', '通讯录', '发现页']
        //                 });
        //                 break;
        //             default:
        //                 throw new Error('参数错误, 可选参数:superAdmin、admin、user')
        //         }
        //     }
        // }
        // let superAdmin = UserFactory('superAdmin');
        // let admin = UserFactory('admin') 
        // let normalUser = UserFactory('user')

        // console.log(superAdmin)
        // console.log(admin)
        // console.log(normalUser)

        // 工厂方法模式的本意是将实际创建对象的工作推迟到子类中，这样核心类就变成了抽象类。但是在JavaScript中很难像传统面向对象那样去实现创建抽象类。
        // 所以在JavaScript中我们只需要参考它的核心思想即可。我们可以将工厂方法看作是一个实例化对象的工厂类。
        // let UserFactory = function (role) {
        //     console.log(this)
        //     if (this instanceof UserFactory) {
        //         return new this[role]
        //     } else {
        //         return new UserFactory(role)
        //     }
        // };
        // UserFactory.prototype = {
        //     SuperAdmin: function () {
        //         this.name = "超级管理员",
        //             this.viewPage = ['首页', '通讯录', '发现页', '应用数据', '权限管理']
        //     },
        //     Admin: function () {
        //         this.name = "管理员",
        //             this.viewPage = ['首页', '通讯录', '发现页', '应用数据']
        //     },
        //     NormalUser: function () {
        //         this.name = '普通用户',
        //             this.viewPage = ['首页', '通讯录', '发现页']
        //     }
        // }
        // class User {
        //     constructor(name = '', viewPage = []) {
        //         if (new.target === User) {
        //             throw new Error('抽象类不能实例化!');
        //         }
        //         this.name = name;
        //         this.viewPage = viewPage;
        //     }
        // }

        // class UserFactory extends User {
        //     constructor(name, viewPage) {
        //         super(name, viewPage)
        //     }
        //     create(role) {
        //         switch (role) {
        //             case 'superAdmin':
        //                 return new UserFactory('超级管理员', ['首页', '通讯录', '发现页', '应用数据', '权限管理']);
        //                 break;
        //             case 'admin':
        //                 return new UserFactory('普通用户', ['首页', '通讯录', '发现页']);
        //                 break;
        //             case 'user':
        //                 return new UserFactory('普通用户', ['首页', '通讯录', '发现页']);
        //                 break;
        //             default:
        //                 throw new Error('参数错误, 可选参数:superAdmin、admin、user')
        //         }
        //     }
        // }


        // let superAdmin = UserFactory('SuperAdmin');
        // let admin = UserFactory('Admin')
        // let normalUser = UserFactory('NormalUser')
        // console.log(superAdmin)
        // console.log(admin)
        // console.log(normalUser)


        // 简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建。
        // 在抽象工厂中，类簇一般用父类定义，并在父类中定义一些抽象方法，再通过抽象工厂让子类继承父类。所以，抽象工厂其实是实现子类继承父类的方法。
        // let AccountAbstractFactory = function (subType, superType) {
        //     if (typeof AccountAbstractFactory[superType] === 'function') {
        //         function F() {};
        //         F.prototype = new AccountAbstractFactory[superType];
        //         subType.constructor = subType;
        //         subType.prototype = new F();
        //     } else {
        //         throw new Error('抽象类不存在!')
        //     }
        // }
        // //微信用户抽象类
        // AccountAbstractFactory.WechatUser = function () {
        //     this.type = 'wechat';
        // }
        // AccountAbstractFactory.WechatUser.prototype = {
        //     getName: function () {
        //         return new Error('抽象方法不能调用');
        //     }
        // }
        // //qq用户抽象类
        // AccountAbstractFactory.QqUser = function () {
        //     this.type = 'qq';
        // }
        // AccountAbstractFactory.QqUser.prototype = {
        //     getName: function () {
        //         return new Error('抽象方法不能调用');
        //     }
        // }
        // //新浪微博用户抽象类
        // AccountAbstractFactory.WeiboUser = function () {
        //     this.type = 'weibo';
        // }
        // AccountAbstractFactory.WeiboUser.prototype = {
        //     getName: function () {
        //         return new Error('抽象方法不能调用');
        //     }
        // }

        // //普通微信用户子类
        // function UserOfWechat(name) {
        //     this.name = name;
        //     this.viewPage = ['首页', '通讯录', '发现页']
        // }
        // //抽象工厂实现WechatUser类的继承
        // AccountAbstractFactory(UserOfWechat, 'WechatUser');
        // //子类中重写抽象方法
        // UserOfWechat.prototype.getName = function () {
        //     return this.name;
        // }

        // //普通qq用户子类
        // function UserOfQq(name) {
        //     this.name = name;
        //     this.viewPage = ['首页', '通讯录', '发现页']
        // }
        // //抽象工厂实现QqUser类的继承
        // AccountAbstractFactory(UserOfQq, 'QqUser');
        // //子类中重写抽象方法
        // UserOfQq.prototype.getName = function () {
        //     return this.name;
        // }

        // //普通微博用户子类
        // function UserOfWeibo(name) {
        //     this.name = name;
        //     this.viewPage = ['首页', '通讯录', '发现页']
        // }
        // //抽象工厂实现WeiboUser类的继承
        // AccountAbstractFactory(UserOfWeibo, 'WeiboUser');
        // //子类中重写抽象方法
        // UserOfWeibo.prototype.getName = function () {
        //     return this.name;
        // }

        // class User {
        //     constructor(type) {
        //         if (new.target === 'User') {
        //             throw new Error('抽象类不能实例化!')
        //         }
        //         this.type = type;
        //     }
        // }

        // class UserOfWechat extends AbstractClass {
        //     constructor(name) {
        //         super('wechat')
        //         this.name = name;
        //         this.viewPage = ['首页', '通讯录', '发现页'];
        //     }
        // }
        // class UserOfQq extends User {
        //     constructor(name) {
        //         super('qq');
        //         this.name = name;
        //         this.viewPage = ['首页', '通讯录', '发现页']
        //     }
        // }

        // class UserOfWeibo extends User {
        //     constructor(name) {
        //         super('weibo');
        //         this.name = name;
        //         this.viewPage = ['首页', '通讯录', '发现页']
        //     }
        // }

        // function getAbstractUserFactory(type) {
        //     switch (type) {
        //         case 'wechat':
        //             return UserOfWechat;
        //             break;
        //         case 'qq':
        //             return UserOfQq;
        //             break;
        //         case 'weibo':
        //             return UserOfWeibo;
        //             break;
        //         default:
        //             throw new Error('参数错误, 可选参数:superAdmin、admin、user')
        //     }
        // }


        // //实例化微信用户
        // let wechatUserA = new UserOfWechat('微信小李');
        // console.log(wechatUserA.getName(), wechatUserA.type); //微信小李 wechat
        // let wechatUserB = new UserOfWechat('微信小王');
        // console.log(wechatUserB.getName(), wechatUserB.type); //微信小王 wechat

        // //实例化qq用户
        // let qqUserA = new UserOfQq('QQ小李');
        // console.log(qqUserA.getName(), qqUserA.type); //QQ小李 qq
        // let qqUserB = new UserOfQq('QQ小王');
        // console.log(qqUserB.getName(), qqUserB.type); //QQ小王 qq

        // //实例化微博用户
        // let weiboUserA = new UserOfWeibo('微博小李');
        // console.log(weiboUserA.getName(), weiboUserA.type); //微博小李 weibo
        // let weiboUserB = new UserOfWeibo('微博小王');
        // console.log(weiboUserB.getName(), weiboUserB.type); //微博小王 weibo
    </script>
</body>

</html>