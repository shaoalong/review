<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>模板模式</title>
</head>

<body>
    <h2>模板模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</h2>
    <h3>优点：1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。</h3>
    <h3>缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大</h3>
    <h3>使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</h3>

    <script>
        const Drinks = function () {}

        Drinks.prototype.firstStep = function () {
            console.log('烧开水')
        }

        Drinks.prototype.secondStep = function () {}

        Drinks.prototype.thirdStep = function () {
            console.log('倒入杯子')
        }

        Drinks.prototype.fourthStep = function () {}
        Drinks.prototype.ifNeedFlavour = function () { // 加上钩子
            return true
        }

        Drinks.prototype.init = function () { // 模板方法模式核心：在父类上定义好执行算法
            this.firstStep()
            this.secondStep()
            this.thirdStep()
            if (this.ifNeedFlavour()) { // 默认是 true，也就是要加调料
                this.fourthStep()
            }
        }
        const Tea = function () {}

        Tea.prototype = new Drinks

        Tea.prototype.secondStep = function () {
            console.log('浸泡茶叶')
        }

        Tea.prototype.fourthStep = function () {
            console.log('加柠檬')
        }

        const Coffee = function () {}

        Coffee.prototype = new Drinks

        Coffee.prototype.secondStep = function () {
            console.log('冲泡咖啡')
        }

        Coffee.prototype.fourthStep = function () {
            console.log('加糖')
        }
        Coffee.prototype.ifNeedFlavour = function () {
            return window.confirm('是否需要佐料吗？') // 弹框选择是否佐料
        }

        const tea = new Tea()
        tea.init()
        const coffee = new Coffee()
        coffee.init()
    </script>
</body>

</html>