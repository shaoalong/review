<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>web缓存</title>
</head>

<body>
  <script>
    // 缓存位置：
		// 	1.Service Worker：是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。
		// 		传输协议必须是HTTPS，因为Service Worker中涉及到请求拦截，所以必须使用HTTPS协议来保障安全。
		// 		它的缓存与浏览器其他内建缓存机制不同，它可以让我们自由控制那些文件，如何匹配缓存，如何读取缓存，
		// 		并且缓存是持续性的。
		// 	2.Memory Cache：也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面中已经下载的样式、
		// 		将本、图片等。读取内存中的数据肯定比磁盘中的快，内存缓存虽然读取高效。可是缓存持续性很短，会随着进程
		// 		的释放而释放。一旦我们关闭了Tab页面，内存中的缓存也就释放了。
		// 		需要注意的是：内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Cotrol是什么值，同时资源的匹配
		// 		也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。
		// 	3.Disk Cache：也就是储存在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中。比Memory Cahce胜在容量和存储时效上。
		// 		在所有浏览器缓存中，Disk Cache覆盖面基本是最大的。它会更建议HTTP Header中的字段判断哪些资源需要缓存，
		// 		哪些资源可以不请求直接使用，那些资源已经过期需要重新请求。并且及时在跨站点的情况下，相同地址的资源一旦被硬盘
    // 		缓存下来，就不会再次去请求数据。
    //    disk cache也叫http cahce，因为其严格遵守http响应头字段来判断哪些资源是否要被缓存，哪些资源是否已经过期。绝大多数缓存都是disk cache。
		// 		总结：
		// 			1.对于大文件来说，大概率是不存在内存中的，反之优先。
		// 			2.当前系统内存使用率高的话，文件优先储存进硬盘。
		// 	4.Push Cache：也就是推送缓存，是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，
		// 		一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。
    //  如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。
      
    // http缓存策略（disk cache）：
    // 强缓存：浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器
    //   expires:Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2016 23:55:55 GMT
    //     读取缓存数据条件：缓存过期时间（服务器）< 当前时间（客户端)
    //     缺点：Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代
    //   cache-control:Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。
    //     读取缓存数据条件：上次缓存时间（客户端）+max-age < 当前时间（客户端）
    //     Public:指示响应可被任何缓存区缓存
    //     Private:指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，此响应消息对于其他用户的请求无效。
    //     no-cache:指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，而是需要和服务器确认
    //     no-store:在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來
    //     max-age:指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。上次缓存时间（客户端的）+max-age（64200s）<客户端当前时间
    //   注意：这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires
    
    // 协商缓存：当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回（304），
    //   但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；若未命中请求，则将资源返回客户端，并更新本地缓存数据（200）。
    //   Last-Modified/If-Modified-Since:
    //     Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。
    //     if-Modified-Since：当资源过期时（强缓存失效），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对
    //     若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。
    //     缺点：
    //       1.Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间（无法及时更新文件）
    //       2.如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存，有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形（无法使用缓存）。
    //   Etag/If-None-Match:为了解决Last-Modified的问题，HTTP1.1中引入了Etag，Etag/If-None-Match也要配合Cache-Control使用
    //     Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。
    //     If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。
    //     web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。
    //     Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag一起使用时，服务器会优先验证ETag。
    
    // 实际场景应用缓存策略：
		// 		1.频繁变动的资源： Cache-Control:no-cache
		// 			对于频繁变动的资源，首先使用Cache-Control： no-cache使浏览器每次都请求服务器，然后配合Etag或者Last-Modified来验证资源是否有效。
		// 			这样做法虽然不能节省请求数量，但是能显著减小相应数据大小。
		// 		2.不常变化的资源： Cache-Control： max-age=31536000
		// 			通常在处理这类资源时，给他们一个Cache-Control配置一个很大的max-age-31536000（一年），这样浏览器之后请求相同的URL会命中强缓存。为了解决更新问题，
		// 			就需要在文件名（或者路径）中加一个hash，版本号等动态字符，之后更改动态字符，从而达到更改引用URL的目的，让之前的强缓存失效（其实并非失效，只是不适用而已）。

    // 用户行为对浏览器缓存的影响：
    //   1. 打开网页，地址栏输入地址：查找disk cahce中是否有匹配。如有则使用；如没有则发送网络请求。
    //   2. 普通刷新（F5）：因为没有关闭Tab页，因此memory cahce是可用的，会被优先使用，其次才是disk cache。
    //   3. 强制刷新（Ctrl+F5）：浏览器不再使用缓存，因此发送的请求头均带有Cache-Control：no-cache（为了兼容还带有Pragma: no-cahce）,服务器直接返回200和最新的内容。
  </script>
</body>

</html>